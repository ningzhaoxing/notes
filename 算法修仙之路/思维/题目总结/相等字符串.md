# 相等字符串

## 题面

![image-20241026173351578](C:\Users\Administrator\AppData\Roaming\Typora\typora-user-images\image-20241026173351578.png)

## 算法思路

- 字符串长度数据范围最大为`10^5`，考虑的时间复杂度至少要在`O(nlogn)`或`O(n)`
- 目的是计算`0`和`1`数目相等的子串(连续)数量
- 我们可以在遍历字符串的过程中，计算每个位置上`1`比`0`多的数目`xi`，当`xi>1`时，则说明可以对组合做出贡献。下面以`11001`(0011的负数有点抽象)举例解释一下为什么是这样的：

![image-20241026174835519](C:\Users\Administrator\AppData\Roaming\Typora\typora-user-images\image-20241026174835519.png)

- 观察两个蓝色的矩形：小的矩形包含的字符串为`"1"`，红色数字代表这个字符串(包含当前位置)，`1`比`0`大的个数为**1**；大的矩形包含的字符串为`"110"`，红色数字代表这个字符串`1`比`0`大的个数也为**1**。

- 那么左边小矩形所包含的字符串多出来了一个`1`，右边大矩形所包含的字符串也多出来一个`1`，那么两者相减，就是一个**相等子串**。

- 当当前位置`1`比`0`大的个数为**0**时，字符串为`"1100"`，其本身就是一个**相等子串**，只有一个`0`也可以形成**相等子串**，所以初始化为**1**。
- 关于组合问题：

上图中有`1`比`0`大的位置三个`1`(顺序标记为①②③)：组合方式分别有：

1.①② 2.②③ 3. ①③

考虑是前者对后者的贡献。当①出现时，为后续出现的`1`贡献1。当②出现时，前者所贡献的`1`生效，组合成一个**相等子串**，并为后者再贡献1，此时贡献为2；当③出现时，可以组合成两个**相等子串**······以此类推。

## 总结

这道题根据数据范围就可以知道，大概率是要遍历一次字符串来解决问题。因为要知道`01`数量是否相等，那必须知道`01`的数量，自己找找规律吧。其次，对于组合的贡献刚开始也不好理解。

学长讲的比较快没讲为什么要这么做了，我刚开始没听懂，不过顺着思路往下思考了一阵，大明白了。学长思路太强了%%%

写题解是希望自己可以加深理解和记忆，如何可以帮助到你，也非常开心！

