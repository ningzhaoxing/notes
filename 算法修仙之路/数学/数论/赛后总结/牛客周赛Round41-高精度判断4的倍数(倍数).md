# 题目

![image-20240506091354271](C:\Users\Administrator\AppData\Roaming\Typora\typora-user-images\image-20240506091354271.png)

# 思路分析

数字串的长度为10^5，暴力模拟O(n^2)显然不可取。问题在于两个点：

1. 每次数列循环会组成一个新的字符串，最长会开到size=2*n-1的地步，显然超出空间限制。
2. 对于位数为10^5的数字该如何判断是否为4的倍数。

- 第二个问题：对于一个数，判断其是否是4的倍数，只需判断其后两位是否是4的倍数，原因如下：

  ​			因为从第三位数起，其每位上的数都是100的整数倍，n*100一定能被4整除；而第一位\*1或第二位\*10都不一定是4的整数倍。所以(n\*100+m)/4，根据乘法分配律，只需要判断m(后两位)是否是4的倍数即可。

- 第一个问题：只需要判断后两位数，我们只需要特判n==1的情况；然后循环每次取两位数进行判断是否是4的倍数即可。

# 错误经历

1. 没有找到正确的切入点，凭感觉关键点可能是0，结果不会做。然后想到如果要模拟就需要在O(n)的时间复杂度内解决。

   - 第一次用substring截取，但substring的时间复杂度为O(n)实际上已经O(n^2)；
   - 第二次用StringBuilder每次删除第一位数字添加第二位数字，但是BigInteger的四则运算时间复杂度也是O(n)；
   - 第三次思考如何不使用BigInteger进行取模运算，答案是不可能的；放弃思考ing。

# 总结

思考到这就该发现模拟是完全没法做的。从一开始纯模拟就一定会O(n^2)，也有对BigInteger的时间复杂度的不熟悉。模拟是不行的，应该从数学关系上将一个高精度数分解成多项式来对4取余，发现两位数以上的位数不需要管，只需要判断后两位即可。

# AC代码

```c++
#include <bits/stdc++.h>
using namespace std;
string s;
void solve() {
    cin>>s;
    int n=s.length();
    if (n==1) {
        if ((s[0]-'0')%4==0) cout<<0;
        else cout<<-1;
        return;
    }
    for(int i=0;i<n;i++) {
        int l=(n+i-2)%n;
        int r=(n+i-1)%n;
        
        if (((s[l]-'0')*10+(s[r]-'0'))%4==0) {
            cout<<i;
            return;
        }
    }
    cout<<-1;
}

int main() {
	ios::sync_with_stdio(0);
	cin.tie(0);
	int T=1;
	//scanf("%d",&T);
	while(T--) solve();
	return 0;
}
```

## 代码技巧

在对字符串进行循环的时候，发现后两位的下标是逢n进1，所以需要对n进行取模，当n-1是可以存在的，所以i从0开始，每一次循环都对之前的后两位下标+1取模。

   

